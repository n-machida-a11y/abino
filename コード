// ----------------------------------------------------------------
// 定数設定
// ----------------------------------------------------------------
const SPREADSHEET_ID = '1RO2XTBsKl6trRxL9SOkDbQ-brx-PaUxeWZBuMiytm7U';
const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
const itemSheet = ss.getSheetByName('物品マスタ');
const rentalSheet = ss.getSheetByName('貸出履歴');
const mailSheet = ss.getSheetByName('メールマスタ'); // ◀◀◀ 修正 (追加)

const HEADER = ['管理番号', '物品名', 'カテゴリ', 'ステータス', '貸与者', '現場名', '貸出日', '返却予定日', '校正日・入替日', '備考'];
// ▼▼▼ 修正 ▼▼▼ J列（インデックス9）に '通知先アドレス' を追加
const HISTORY_HEADER = ['履歴ID', '管理番号', '物品名', '処理', '貸与者', '現場名', '貸与日', '返却予定日', '実返却日', '通知先アドレス'];

// ----------------------------------------------------------------
// Webページ表示
// ----------------------------------------------------------------
function doGet(e) {
    return HtmlService.createTemplateFromFile('index')
        .evaluate()
        .setTitle('貸与品管理アプリ') // タイトルを変更
        .addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

// ----------------------------------------------------------------
// データ取得系
// ----------------------------------------------------------------
function getInitialData() {
    try {
        const itemValues = itemSheet.getLastRow() > 1 ? itemSheet.getRange(2, 1, itemSheet.getLastRow() - 1, HEADER.length).getValues() : [];
        const rentalValues = rentalSheet.getLastRow() > 1 ? rentalSheet.getRange(2, 1, rentalSheet.getLastRow() - 1, HISTORY_HEADER.length).getValues() : [];

        itemValues.sort((a, b) => {
            const categoryA = a[2] || '';
            const categoryB = b[2] || '';
            const nameA = a[1] || '';
            const nameB = b[1] || '';
            if (categoryA < categoryB) return -1;
            if (categoryA > categoryB) return 1;
            if (nameA < nameB) return -1;
            if (nameA > nameB) return 1;
            return 0;
        });

        const items = itemValues.map(row => formatRowAsObject(row, HEADER));
        const rentals = rentalValues.map(row => formatRowAsObject(row, HISTORY_HEADER));

        return { items: items, rentals: rentals };
    } catch(e) {
        console.error("getInitialData Error: " + e.message + e.stack);
        return { items: [], rentals: [] };
    }
}

/**
 * 物品の貸出制約と今後のスケジュールを取得します。
 * @param {string} itemId 管理番号
 * @return {object} 制約情報とスケジュールリスト
 */
function getItemScheduleInfo(itemId) {
    const futureEvents = getFutureEventsForItem(itemId);
    const nextReservation = futureEvents.find(event => event[3] === '予約');
    
    let constraints = {
        latestReturnDate: null,
        message: ''
    };

    if (nextReservation) {
        const nextReservationStartDate = normalizeDate(nextReservation[6]);
        const latestReturnDate = new Date(nextReservationStartDate.getTime());
        latestReturnDate.setDate(latestReturnDate.getDate() - 1);
        constraints.latestReturnDate = Utilities.formatDate(latestReturnDate, Session.getScriptTimeZone(), 'yyyy-MM-dd');
        constraints.message = `注意: この物品は${Utilities.formatDate(nextReservationStartDate, 'JST', 'M月d日')}から予約が入っています。`;
    }

    const schedule = futureEvents.map(event => {
        return {
            type: event[3], // '貸出' or '予約'
            borrower: event[4],
            siteName: event[5] || '',
            startDate: Utilities.formatDate(normalizeDate(event[6]), Session.getScriptTimeZone(), 'yyyy/MM/dd'),
            endDate: Utilities.formatDate(normalizeDate(event[7]), Session.getScriptTimeZone(), 'yyyy/MM/dd'),
        }
    });

    return { constraints: constraints, schedule: schedule };
}


/**
 * 特定の物品の編集可能なスケジュール（現在の貸出と今後の予約）を取得します。
 * @param {string} itemId 管理番号
 * @return {Array} スケジュールオブジェクトの配列
 */
function getEditableSchedulesForItem(itemId) {
    const lastRow = rentalSheet.getLastRow();
    if (lastRow < 2) return [];
    const values = rentalSheet.getRange(2, 1, lastRow - 1, HISTORY_HEADER.length).getValues();
    const today = normalizeDate(new Date());

    const schedules = values
        .filter(row => {
            const isTargetItem = row[1] == itemId;
            const isEditableStatus = ['貸出', '予約'].includes(row[3]);
            // 返却予定日が今日以降のものを対象とする
            const eventEndDate = normalizeDate(row[7]);
            return isTargetItem && isEditableStatus && eventEndDate >= today;
        })
        .map(row => {
            const history = formatRowAsObject(row, HISTORY_HEADER);
            return {
                historyId: history.履歴ID,
                type: history.処理,
                borrower: history.貸与者,
                siteName: history.現場名,
                startDate: history.貸与日,
                returnDate: history.返却予定日,
                itemName: history.物品名,
                email: history.通知先アドレス || '' // ▼▼▼ 修正 ▼▼▼ email を追加
            };
        })
        .sort((a,b) => new Date(a.startDate) - new Date(b.startDate));
    
    return schedules;
}


// ----------------------------------------------------------------
// データ操作系 (物品一覧)
// ----------------------------------------------------------------
function addItem(itemData) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        if (!itemData.管理番号) {
            throw new Error('管理番号が指定されていません。');
        }
        const existingRow = findRowById(itemSheet, itemData.管理番号);
        if (existingRow !== -1) {
            throw new Error('その管理番号は既に使用されています。');
        }
        
        itemData.ステータス = '在庫';
        itemData.貸与者 = '';
        itemData.貸出日 = '';
        itemData.現場名 = '';
        itemData.返却予定日 = '';

        const newRow = HEADER.map(key => {
            if (['校正日・入替日'].includes(key) && itemData[key]) {
                return normalizeDate(itemData[key]);
            }
            return itemData[key] || '';
        });
        itemSheet.appendRow(newRow);
        
        return { success: true, message: '新しい物品を登録しました。', shouldReload: true };
    } catch (e) { 
        console.error('Error in addItem: ' + e.message + e.stack); 
        return { success: false, message: '登録に失敗しました: ' + e.message }; 
    } finally {
        lock.releaseLock();
    }
}

function updateItem(itemData) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        const originalId = itemData.original管理番号;
        const newId = itemData.管理番号;

        const itemRow = findRowById(itemSheet, originalId);
        if (itemRow === -1) throw new Error('対象の物品が見つかりません。');
        
        // IDが変更された場合、新しいIDが既に存在しないかチェック
        if (originalId !== newId) {
            const existingRow = findRowById(itemSheet, newId);
            if (existingRow !== -1) {
                throw new Error(`管理番号「${newId}」は既に使用されています。`);
            }
        }
        
        // 物品マスタの行を更新
        const itemRange = itemSheet.getRange(itemRow, 1, 1, HEADER.length);
        const currentValues = itemRange.getValues()[0];
        const newRowData = HEADER.map((key, index) => {
            if (itemData.hasOwnProperty(key)) {
                if (['校正日・入替日'].includes(key) && itemData[key]) {
                    return normalizeDate(itemData[key]);
                }
                return itemData[key] || '';
            }
            return currentValues[index];
        });
        itemRange.setValues([newRowData]);

        // IDが変更された場合、貸出履歴シートの関連レコードも更新
        if (originalId !== newId) {
            const rentalValues = rentalSheet.getDataRange().getValues();
            const idColIndex = HISTORY_HEADER.indexOf('管理番号');
            
            for (let i = 1; i < rentalValues.length; i++) { // ヘッダー行を除く
                if (String(rentalValues[i][idColIndex]) === String(originalId)) {
                    rentalSheet.getRange(i + 1, idColIndex + 1).setValue(newId);
                }
            }
        }
        
        return { success: true, message: '物品情報を更新しました。', shouldReload: true };
    } catch (e) { 
        console.error('Error in updateItem: ' + e.message + e.stack); 
        return { success: false, message: '更新に失敗しました: ' + e.message }; 
    } finally {
        lock.releaseLock();
    }
}

function deleteItem(itemId) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        const itemRow = findRowById(itemSheet, itemId);
        if (itemRow === -1) throw new Error('対象の物品が見つかりません。');

        const status = itemSheet.getRange(itemRow, HEADER.indexOf('ステータス') + 1).getValue();
        if(status === '貸出中') throw new Error('貸出中の物品は削除できません。');

        const futureEvents = getFutureEventsForItem(itemId);
        if (futureEvents.length > 0) throw new Error('この物品には予約が入っているため削除できません。');

        itemSheet.deleteRow(itemRow);
        return { success: true, message: '物品を削除しました。', shouldReload: true };
    } catch (e) { 
        console.error('Error in deleteItem: ' + e.message + e.stack); 
        return { success: false, message: `削除に失敗しました: ${e.message}` }; 
    } finally {
        lock.releaseLock();
    }
}

// ----------------------------------------------------------------
// 貸出・返却・予約 処理
// ----------------------------------------------------------------
function lendItem(data) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        // ▼▼▼ 修正: data から email を受け取り、現場名と貸与者の必須チェックを追加 ▼▼▼
        const { itemId, borrower, siteName, startDate, returnDate, email } = data;
        if (!borrower) throw new Error('貸与者が入力されていません。');
        if (!siteName) throw new Error('現場名が入力されていません。');
        // ▲▲▲ 修正ここまで ▲▲▲

        const itemRow = findRowById(itemSheet, itemId);
        if (itemRow === -1) throw new Error('対象の物品が見つかりません。');

        const itemDataValues = itemSheet.getRange(itemRow, 1, 1, HEADER.length).getValues()[0];
        const maintenanceDate = itemDataValues[HEADER.indexOf('校正日・入替日')];
        if (maintenanceDate instanceof Date) {
            const today = normalizeDate(new Date());
            if (normalizeDate(maintenanceDate) < today) {
                throw new Error(`この物品は校正・入替期限(${Utilities.formatDate(maintenanceDate, Session.getScriptTimeZone(), 'yyyy/MM/dd')})を過ぎているため、貸し出せません。`);
            }
        }
        
        const currentStatus = itemSheet.getRange(itemRow, HEADER.indexOf('ステータス') + 1).getValue();
        if (['貸出中'].includes(currentStatus)) {
            throw new Error('この物品は現在貸出中のため、新たに貸し出すことはできません。');
        }
        
        const checkResult = checkAvailability(itemId, new Date(startDate), new Date(returnDate));
        if (!checkResult.isAvailable) {
            throw new Error(`貸出期間が他の予定と重複しています。\n重複期間: ${checkResult.conflictReason}`);
        }

        // ▼▼▼ 修正: data (email含む) を addHistoryRecord に渡す ▼▼▼
        addHistoryRecord(itemId, null, '貸出', data);
        updateItemStatus(itemId);

        // ◀◀◀ メール送信処理 ◀◀◀
        if (email || (typeof mailSheet !== 'undefined' && mailSheet)) { 
            const itemName = getItemNameById(itemId);
            const subject = `【貸与品管理】物品貸出通知 (${itemName})`;
            const body =
`${borrower} 様（または現場担当者 様）

以下の内容で物品の貸出が実行されました。

物品名: ${itemName} (管理番号: ${itemId})
貸与者: ${borrower}
現場名: ${siteName || 'N/A'}
貸出日: ${Utilities.formatDate(normalizeDate(startDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}
返却予定日: ${Utilities.formatDate(normalizeDate(returnDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}

---
貸与品管理アプリ`;

            // フォームからのメールアドレスと、件名・本文を渡す
            sendNotificationEmail(email, subject, body);
        }
        // ◀◀◀ 修正ここまで ◀◀◀

        return { success: true, message: '貸出処理が完了しました。', shouldReload: true };
    } catch (e) { 
        console.error('Error in lendItem: ' + e.message + e.stack); 
        return { success: false, message: `貸出処理に失敗しました: ${e.message}` }; 
    } finally {
        lock.releaseLock();
    }
}

function returnItem(historyId) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        const historyRow = findRowById(rentalSheet, historyId);
        if (historyRow === -1) throw new Error('対象の履歴が見つかりません。');

        const historyRange = rentalSheet.getRange(historyRow, 1, 1, HISTORY_HEADER.length);
        const historyValues = historyRange.getValues()[0];
        
        const currentStatus = historyValues[HISTORY_HEADER.indexOf('処理')];
        if (currentStatus === '返却済み') {
            throw new Error('この貸出は既に返却済みです。');
        }

        historyValues[HISTORY_HEADER.indexOf('処理')] = '返却済み';
        historyValues[HISTORY_HEADER.indexOf('実返却日')] = new Date(); // Record actual return date
        historyRange.setValues([historyValues]);

        const itemId = historyValues[HISTORY_HEADER.indexOf('管理番号')];
        updateItemStatus(itemId);

        // ◀◀◀ メール送信処理 ◀◀◀
        const email = historyValues[HISTORY_HEADER.indexOf('通知先アドレス')];
        if (email || (typeof mailSheet !== 'undefined' && mailSheet)) {
            const itemName = getItemNameById(itemId);
            const borrower = historyValues[HISTORY_HEADER.indexOf('貸与者')];
            const siteName = historyValues[HISTORY_HEADER.indexOf('現場名')];
            const startDate = historyValues[HISTORY_HEADER.indexOf('貸与日')];
            const returnDate = historyValues[HISTORY_HEADER.indexOf('実返却日')]; // 実返却日を通知

            const subject = `【貸与品管理】物品返却通知 (${itemName})`;
            const body =
`${borrower} 様（または現場担当者 様）

以下の物品が返却されました。

物品名: ${itemName} (管理番号: ${itemId})
貸与者: ${borrower}
現場名: ${siteName || 'N/A'}
貸出日: ${Utilities.formatDate(normalizeDate(startDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}
実返却日: ${Utilities.formatDate(normalizeDate(returnDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}

---
貸与品管理アプリ`;

            sendNotificationEmail(email, subject, body);
        }
        // ◀◀◀ 修正ここまで ◀◀◀

        return { success: true, message: '返却処理が完了しました。', shouldReload: true };
    } catch (e) { 
        console.error('Error in returnItem: ' + e.message + e.stack); 
        return { success: false, message: '返却処理に失敗しました: ' + e.message }; 
    } finally {
        lock.releaseLock();
    }
}

/**
 * 貸出中の物品の貸与者、現場名、期間、通知先アドレスを更新します。
* @param {object} data - { itemId, borrower, siteName, newStartDate, newReturnDate, email }
 */
function updateRentalPeriod(data) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        // ▼▼▼ 修正: data から email を受け取り、現場名と貸与者の必須チェックを追加 ▼▼▼
        const { itemId, borrower, siteName, newStartDate, newReturnDate, email } = data;
        if (!borrower) throw new Error('貸与者が入力されていません。');
        if (!siteName) throw new Error('現場名が入力されていません。');
        // ▲▲▲ 修正ここまで ▲▲▲

        const itemRow = findRowById(itemSheet, itemId);
        if (itemRow === -1) throw new Error('対象の物品が見つかりません。');

        // 校正日チェック
        const itemDataValues = itemSheet.getRange(itemRow, 1, 1, HEADER.length).getValues()[0];
        const maintenanceDate = itemDataValues[HEADER.indexOf('校正日・入替日')];
        if (maintenanceDate instanceof Date) {
            if (normalizeDate(newReturnDate) > normalizeDate(maintenanceDate)) {
                throw new Error(`返却日は校正・入替期限(${Utilities.formatDate(maintenanceDate, Session.getScriptTimeZone(), 'yyyy/MM/dd')})を超えることはできません。`);
            }
        }

        // 更新対象の「貸出」履歴を探す
        const historyValues = rentalSheet.getDataRange().getValues();
        // 履歴がヘッダー行(1行)のみの場合、探す必要がないので早期リターン
        if (historyValues.length < 2) throw new Error('更新対象の貸出履歴が見つかりません。');
        
        const historyRowIndex = historyValues.length - 1 - [...historyValues].reverse().findIndex(row => row[1] == itemId && row[3] === '貸出');
        if (historyRowIndex < 1) throw new Error('更新対象の貸出履歴が見つかりません。'); // 0はヘッダーなので < 1
        
        // 重複チェック (自分自身の履歴IDを除外)
        const historyIdToIgnore = historyValues[historyRowIndex][0];
        const checkResult = checkAvailability(itemId, new Date(newStartDate), new Date(newReturnDate), true, historyIdToIgnore);
        if (!checkResult.isAvailable) {
            throw new Error(`変更後の期間が他の予定と重複しています。\n重複期間: ${checkResult.conflictReason}`);
        }

        // 物品マスタ(itemSheet)の更新
        itemSheet.getRange(itemRow, HEADER.indexOf('貸与者') + 1).setValue(borrower);
        itemSheet.getRange(itemRow, HEADER.indexOf('現場名') + 1).setValue(siteName);
        // ▼▼▼ 修正: 日付型の値を日付文字列に変換して保存（index.htmlでの表示を確実にするため） ▼▼▼
        itemSheet.getRange(itemRow, HEADER.indexOf('貸出日') + 1).setValue(Utilities.formatDate(normalizeDate(newStartDate), Session.getScriptTimeZone(), 'yyyy/MM/dd'));
        itemSheet.getRange(itemRow, HEADER.indexOf('返却予定日') + 1).setValue(Utilities.formatDate(normalizeDate(newReturnDate), Session.getScriptTimeZone(), 'yyyy/MM/dd'));
        // ▲▲▲ 修正ここまで ▲▲▲
        
        // 貸出履歴(rentalSheet)の更新 (historyRowIndex は 0-based なので、Range指定は +1 する)
        const historyRow = historyRowIndex + 1;
        rentalSheet.getRange(historyRow, HISTORY_HEADER.indexOf('貸与者') + 1).setValue(borrower);
        rentalSheet.getRange(historyRow, HISTORY_HEADER.indexOf('現場名') + 1).setValue(siteName);
        rentalSheet.getRange(historyRow, HISTORY_HEADER.indexOf('貸与日') + 1).setValue(normalizeDate(newStartDate));
        rentalSheet.getRange(historyRow, HISTORY_HEADER.indexOf('返却予定日') + 1).setValue(normalizeDate(newReturnDate));
        rentalSheet.getRange(historyRow, HISTORY_HEADER.indexOf('通知先アドレス') + 1).setValue(email || '');
        
        // ◀◀◀ メール送信処理 ◀◀◀
        if (email || (typeof mailSheet !== 'undefined' && mailSheet)) {
            const itemName = getItemNameById(itemId);
            const subject = `【貸与品管理】貸出内容変更通知 (${itemName})`;
            const body =
`貸出内容が変更されました。

物品名: ${itemName} (管理番号: ${itemId})
貸与者: ${borrower}
現場名: ${siteName || 'N/A'}
新しい貸出日: ${Utilities.formatDate(normalizeDate(newStartDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}
新しい返却予定日: ${Utilities.formatDate(normalizeDate(newReturnDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}

---
貸与品管理アプリ`;

            sendNotificationEmail(email, subject, body);
        }
        // ◀◀◀ 修正ここまで ◀◀◀

        return { success: true, message: '貸出内容を更新しました。', shouldReload: true };
    } catch (e) {
        console.error('Error in updateRentalPeriod: ' + e.message + e.stack);
        return { success: false, message: `貸出内容の更新に失敗しました: ${e.message}` };
    } finally {
        lock.releaseLock();
    }
}

function addReservation(data) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        // ▼▼▼ 修正: data から email を受け取り、現場名と予約者の必須チェックを追加 ▼▼▼
        const { itemId, borrower, siteName, startDate, returnDate, email } = data;
        if (!borrower) throw new Error('予約者が入力されていません。');
        if (!siteName) throw new Error('現場名が入力されていません。');
        // ▲▲▲ 修正ここまで ▲▲▲

        const itemRow = findRowById(itemSheet, itemId);
        if (itemRow === -1) throw new Error('対象の物品が見つかりません。');
        
        const itemDataValues = itemSheet.getRange(itemRow, 1, 1, HEADER.length).getValues()[0];
        const maintenanceDate = itemDataValues[HEADER.indexOf('校正日・入替日')];
        if (maintenanceDate instanceof Date) {
            const today = normalizeDate(new Date());
            // 予約の終了日が校正日を過ぎていたらNG（貸出とロジックを合わせる）
            if (normalizeDate(returnDate) > normalizeDate(maintenanceDate)) {
                throw new Error(`予約終了日は校正・入替期限(${Utilities.formatDate(maintenanceDate, Session.getScriptTimeZone(), 'yyyy/MM/dd')})を超えることはできません。`);
            }
            if (normalizeDate(maintenanceDate) < today) {
                throw new Error(`この物品は校正・入替期限(${Utilities.formatDate(maintenanceDate, Session.getScriptTimeZone(), 'yyyy/MM/dd')})を過ぎているため、予約できません。`);
            }
        }

        const checkResult = checkAvailability(itemId, new Date(startDate), new Date(returnDate));
        if (!checkResult.isAvailable) {
            throw new Error(`予約期間が他の予定と重複しています。\n重複期間: ${checkResult.conflictReason}`);
        }

        // ▼▼▼ 修正: data (email含む) を addHistoryRecord に渡す ▼▼▼
        addHistoryRecord(itemId, null, '予約', data);
        updateItemStatus(itemId);

        // ◀◀◀ メール送信処理 ◀◀◀
        if (email || (typeof mailSheet !== 'undefined' && mailSheet)) {
            const itemName = getItemNameById(itemId);
            const subject = `【貸与品管理】物品予約通知 (${itemName})`;
            const body =
`${borrower} 様（または現場担当者 様）

以下の内容で物品の予約が実行されました。

物品名: ${itemName} (管理番号: ${itemId})
予約者: ${borrower}
現場名: ${siteName || 'N/A'}
予約開始日: ${Utilities.formatDate(normalizeDate(startDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}
予約終了日: ${Utilities.formatDate(normalizeDate(returnDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}

---
貸与品管理アプリ`;

            sendNotificationEmail(email, subject, body);
        }
        // ◀◀◀ 修正ここまで ◀◀◀

        return { success: true, message: '予約を受け付けました。', shouldReload: true };
    } catch (e) {
        console.error('Error in addReservation: ' + e.message + e.stack);
        return { success: false, message: `予約に失敗しました: ${e.message}` };
    } finally {
        lock.releaseLock();
    }
}

function updateReservation(data) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        // ▼▼▼ 修正: data から email を受け取り、現場名と予約者の必須チェックを追加 ▼▼▼
        const { historyId, borrower, siteName, newStartDate, newReturnDate, email } = data;
        if (!borrower) throw new Error('予約者が入力されていません。');
        if (!siteName) throw new Error('現場名が入力されていません。');
        // ▲▲▲ 修正ここまで ▲▲▲
        
        const historyRow = findRowById(rentalSheet, historyId);
        if (historyRow === -1) throw new Error('対象の予約が見つかりません。');

        const historyRange = rentalSheet.getRange(historyRow, 1, 1, HISTORY_HEADER.length);
        const historyValues = historyRange.getValues()[0];
        const itemId = historyValues[HISTORY_HEADER.indexOf('管理番号')];

        // 校正日チェック
        const itemRow = findRowById(itemSheet, itemId);
        if (itemRow !== -1) {
            const itemDataValues = itemSheet.getRange(itemRow, 1, 1, HEADER.length).getValues()[0];
            const maintenanceDate = itemDataValues[HEADER.indexOf('校正日・入替日')];
            if (maintenanceDate instanceof Date) {
                if (normalizeDate(newReturnDate) > normalizeDate(maintenanceDate)) {
                    throw new Error(`予約終了日は校正・入替期限(${Utilities.formatDate(maintenanceDate, Session.getScriptTimeZone(), 'yyyy/MM/dd')})を超えることはできません。`);
                }
            }
        }

        // 重複チェック (自分自身の履歴IDを除外)
        const checkResult = checkAvailability(itemId, new Date(newStartDate), new Date(newReturnDate), false, historyId);
        if (!checkResult.isAvailable) {
            throw new Error(`変更後の期間が他の予定と重複しています。\n重複期間: ${checkResult.conflictReason}`);
        }

        historyValues[HISTORY_HEADER.indexOf('貸与者')] = borrower;
        historyValues[HISTORY_HEADER.indexOf('現場名')] = siteName;
        historyValues[HISTORY_HEADER.indexOf('貸与日')] = normalizeDate(newStartDate);
        historyValues[HISTORY_HEADER.indexOf('返却予定日')] = normalizeDate(newReturnDate);
        historyValues[HISTORY_HEADER.indexOf('通知先アドレス')] = email || '';
        
        historyRange.setValues([historyValues]);
        
        // ◀◀◀ メール送信処理 ◀◀◀
        if (email || (typeof mailSheet !== 'undefined' && mailSheet)) {
            const itemName = getItemNameById(itemId);
            const subject = `【貸与品管理】予約内容変更通知 (${itemName})`;
            const body =
`予約内容が変更されました。

物品名: ${itemName} (管理番号: ${itemId})
予約者: ${borrower}
現場名: ${siteName || 'N/A'}
新しい予約開始日: ${Utilities.formatDate(normalizeDate(newStartDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}
新しい予約終了日: ${Utilities.formatDate(normalizeDate(newReturnDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}

---
貸与品管理アプリ`;

            sendNotificationEmail(email, subject, body);
        }
        // ◀◀◀ 修正ここまで ◀◀◀
        
        return { success: true, message: '予約内容を更新しました。', shouldReload: true };
    } catch (e) {
        console.error('Error in updateReservation: ' + e.message + e.stack);
        return { success: false, message: `予約の更新に失敗しました: ${e.message}` };
    } finally {
        lock.releaseLock();
    }
}


function cancelReservation(historyId) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        const historyRow = findRowById(rentalSheet, historyId);
        if (historyRow === -1) throw new Error('対象の予約が見つかりません。');
        
        const historyRange = rentalSheet.getRange(historyRow, 1, 1, HISTORY_HEADER.length);
        const historyValues = historyRange.getValues()[0];
        const itemId = historyValues[HISTORY_HEADER.indexOf('管理番号')];
        const email = historyValues[HISTORY_HEADER.indexOf('通知先アドレス')]; // メール送信のために取得

        historyValues[HISTORY_HEADER.indexOf('処理')] = 'キャンセル済';
        historyRange.setValues([historyValues]);
        
        updateItemStatus(itemId);
        
        // ◀◀◀ メール送信処理 ◀◀◀
        if (email || (typeof mailSheet !== 'undefined' && mailSheet)) {
            const itemName = getItemNameById(itemId);
            const borrower = historyValues[HISTORY_HEADER.indexOf('貸与者')];
            const siteName = historyValues[HISTORY_HEADER.indexOf('現場名')];
            const startDate = historyValues[HISTORY_HEADER.indexOf('貸与日')];
            const returnDate = historyValues[HISTORY_HEADER.indexOf('返却予定日')];

            const subject = `【貸与品管理】予約キャンセル通知 (${itemName})`;
            const body =
`${borrower} 様（または現場担当者 様）

以下の予約がキャンセルされました。

物品名: ${itemName} (管理番号: ${itemId})
予約者: ${borrower}
現場名: ${siteName || 'N/A'}
予約開始日: ${Utilities.formatDate(normalizeDate(startDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}
予約終了日: ${Utilities.formatDate(normalizeDate(returnDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}

---
貸与品管理アプリ`;

            sendNotificationEmail(email, subject, body);
        }
        // ◀◀◀ 修正ここまで ◀◀◀

        return { success: true, message: '予約をキャンセルしました。', shouldReload: true };
    } catch(e) {
        console.error('Error in cancelReservation: ' + e.message + e.stack);
        return { success: false, message: `予約のキャンセルに失敗しました: ${e.message}` };
    } finally {
        lock.releaseLock();
    }
}

function lendFromReservation(historyId) {
    const lock = LockService.getScriptLock();
    lock.waitLock(15000);
    try {
        const historyRow = findRowById(rentalSheet, historyId);
        if (historyRow === -1) throw new Error('対象の予約が見つかりません。');

        const historyRange = rentalSheet.getRange(historyRow, 1, 1, HISTORY_HEADER.length);
        const historyValues = historyRange.getValues()[0];
        
        const currentStatus = historyValues[HISTORY_HEADER.indexOf('処理')];
        if (currentStatus !== '予約') {
            throw new Error('この履歴は予約ではないため、貸出処理を実行できません。');
        }
        const startDate = normalizeDate(historyValues[HISTORY_HEADER.indexOf('貸与日')]);
        const today = normalizeDate(new Date());

        if (startDate > today) {
            throw new Error(`この予約は${Utilities.formatDate(startDate, 'JST', 'M月d日')}開始のため、まだ貸し出せません。`);
        }

        historyValues[HISTORY_HEADER.indexOf('処理')] = '貸出';
        historyRange.setValues([historyValues]);
        
        const itemId = historyValues[HISTORY_HEADER.indexOf('管理番号')];
        const email = historyValues[HISTORY_HEADER.indexOf('通知先アドレス')]; // メール送信のために取得
        updateItemStatus(itemId);
        
        // ◀◀◀ メール送信処理 ◀◀◀
        if (email || (typeof mailSheet !== 'undefined' && mailSheet)) {
            const itemName = getItemNameById(itemId);
            const borrower = historyValues[HISTORY_HEADER.indexOf('貸与者')];
            const siteName = historyValues[HISTORY_HEADER.indexOf('現場名')];
            const startDate = historyValues[HISTORY_HEADER.indexOf('貸与日')];
            const returnDate = historyValues[HISTORY_HEADER.indexOf('返却予定日')];

            const subject = `【貸与品管理】自動貸出開始通知 (${itemName})`;
            const body =
`${borrower} 様（または現場担当者 様）

以下の予約が自動で貸出中に変更されました。

物品名: ${itemName} (管理番号: ${itemId})
貸与者: ${borrower}
現場名: ${siteName || 'N/A'}
貸出日: ${Utilities.formatDate(normalizeDate(startDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}
返却予定日: ${Utilities.formatDate(normalizeDate(returnDate), Session.getScriptTimeZone(), 'yyyy/MM/dd')}

---
貸与品管理アプリ`;

            sendNotificationEmail(email, subject, body);
        }
        // ◀◀◀ 修正ここまで ◀◀◀

        return { success: true, message: '予約を貸出中に変更しました。', shouldReload: true };
    } catch(e) {
        console.error('Error in lendFromReservation: ' + e.message + e.stack);
        return { success: false, message: `貸出処理に失敗しました: ${e.message}` };
    } finally {
        lock.releaseLock();
    }
}

// ----------------------------------------------------------------
// カレンダー用データ取得関数
// ----------------------------------------------------------------
function getItemsAsResources() {
    try {
        const itemValues = itemSheet.getLastRow() > 1 ? itemSheet.getRange(2, 1, itemSheet.getLastRow() - 1, HEADER.length).getValues() : [];
        return itemValues.map(row => ({ 
            id: row[0], 
            title: row[1],
            category: row[2]
        }));
    } catch (e) { console.error('Error in getItemsAsResources: ' + e.message + e.stack); return []; }
}

function getCalendarEvents() {
    // 貸出・予約イベントの取得
    const rentalLastRow = rentalSheet.getLastRow();
    const rentalValues = rentalLastRow < 2 ? [] : rentalSheet.getRange(2, 1, rentalLastRow - 1, HISTORY_HEADER.length).getValues();

    const rentalEvents = rentalValues
        .filter(row => ['貸出', '予約', '返却済み'].includes(row[3]))
        .map(row => {
            const history = formatRowAsObject(row, HISTORY_HEADER);
            const startDate = normalizeDate(history.貸与日);
            
            let effectiveEndDate = normalizeDate(history.返却予定日);
            if (history.処理 === '返却済み' && history.実返却日) {
                effectiveEndDate = normalizeDate(history.実返却日);
            }

            const endForCalendar = new Date(effectiveEndDate.getTime());
            endForCalendar.setDate(endForCalendar.getDate() + 1);

            let eventData = {
                id: history.履歴ID,
                resourceId: history.管理番号,
                start: Utilities.formatDate(startDate, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
                end: Utilities.formatDate(endForCalendar, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
                extendedProps: {
                    historyId: history.履歴ID,
                    itemId: history.管理番号, 
                    itemName: history.物品名, 
                    borrower: history.貸与者,
                    startDate: history.貸与日, 
                    returnDate: history.返却予定日,
                    actualReturnDate: history.実返却日 || null,
                    siteName: history.現場名,
                    email: history.通知先アドレス || ''
                }
            };

            switch(history.処理) {
                case '貸出':
                    eventData.title = `${history.現場名 || history.貸与者} (貸出)`;
                    eventData.backgroundColor = '#d9534f';
                    eventData.borderColor = '#d43f3a';
                    eventData.extendedProps.type = 'rental';
                    break;
                case '予約':
                    eventData.title = `${history.現場名 || history.貸与者} (予約)`;
                    eventData.backgroundColor = '#f0ad4e';
                    eventData.borderColor = '#eea236';
                    eventData.extendedProps.type = 'reservation';
                    break;
                case '返却済み':
                    eventData.title = `【返却済み】${history.現場名 || history.貸与者}`;
                    eventData.backgroundColor = '#adb5bd';
                    eventData.borderColor = '#6c757d';
                    eventData.extendedProps.type = 'returned';
                    break;
            }
            return eventData;
        });

    // 校正日・入替日イベントの取得
    const itemLastRow = itemSheet.getLastRow();
    const itemValues = itemLastRow < 2 ? [] : itemSheet.getRange(2, 1, itemLastRow - 1, HEADER.length).getValues();
    
    const maintenanceEvents = itemValues
        .map(row => formatRowAsObject(row, HEADER))
        .filter(item => item['校正日・入替日'])
        .map(item => {
            const maintenanceDate = normalizeDate(item['校正日・入替日']);
            return {
                id: `maint_${item.管理番号}`,
                resourceId: item.管理番号,
                title: `校正/入替: ${item.物品名}`,
                start: Utilities.formatDate(maintenanceDate, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
                allDay: true,
                backgroundColor: '#6c757d',
                borderColor: '#6c757d',
                extendedProps: {
                    type: 'maintenance',
                    itemId: item.管理番号,
                    itemName: item.物品名,
                    maintenanceDate: Utilities.formatDate(maintenanceDate, Session.getScriptTimeZone(), 'yyyy/MM/dd')
                }
            };
        });
    
    return [...rentalEvents, ...maintenanceEvents];
}


// ----------------------------------------------------------------
// スケジュール設定
// ----------------------------------------------------------------
function processReservations() {
    console.log("予約の自動貸出処理を開始します。");
    const lock = LockService.getScriptLock();
    if (!lock.tryLock(300000)) {
        console.log("他のプロセスが実行中のため、スキップします。");
        return;
    }

    try {
        const today = normalizeDate(new Date());

        if (rentalSheet.getLastRow() < 2) {
            console.log("処理対象の予約はありません。");
            return;
        }
        const events = rentalSheet.getRange(2, 1, rentalSheet.getLastRow() - 1, HISTORY_HEADER.length).getValues();

        events.forEach((event, index) => {
            const status = event[3];
            const startDate = normalizeDate(event[6]);
            
            if (status === '予約' && startDate.getTime() === today.getTime()) {
                const itemId = event[1];
                const itemRow = findRowById(itemSheet, itemId);
                
                if (itemRow !== -1) {
                    const itemStatus = itemSheet.getRange(itemRow, HEADER.indexOf('ステータス') + 1).getValue();
                    if (itemStatus === '予約あり') {
                        console.log(`予約ID[${event[0]}]を自動で貸し出します。`);
                        rentalSheet.getRange(index + 2, HISTORY_HEADER.indexOf('処理') + 1).setValue('貸出');
                        SpreadsheetApp.flush();
                        updateItemStatus(itemId);
                    } else {
                        console.log(`物品[${itemId}]が返却されていないため、予約ID[${event[0]}]の自動貸出をスキップしました。`);
                    }
                }
            }
        });
        console.log("予約の自動貸出処理が完了しました。");
    } catch (e) {
        console.error("予約の自動貸出処理中にエラーが発生しました: ", e.message + e.stack);
    } finally {
        lock.releaseLock();
    }
}

// ----------------------------------------------------------------
// ヘルパー関数
// ----------------------------------------------------------------
function addHistoryRecord(itemId, itemName, action, data) {
    const id = getNextId(rentalSheet);
    // itemName が null の場合のフォールバックを修正 (前のコードを参考に)
    const name = itemName || (itemId ? getItemNameById(itemId) : '不明な物品'); 
    const newRow = [
        id, itemId, name, action, data.borrower,
        data.siteName || '',
        normalizeDate(data.startDate), normalizeDate(data.returnDate),
        '', // 実返却日
        data.email || '' // J列に email を保存
    ];
    rentalSheet.appendRow(newRow);
}

function updateItemStatus(itemId) {
    const itemRow = findRowById(itemSheet, itemId);
    if (itemRow === -1) return;

    const itemRange = itemSheet.getRange(itemRow, 1, 1, HEADER.length);
    const itemValues = itemRange.getValues()[0];
    const allFutureEvents = getFutureEventsForItem(itemId);
    const today = normalizeDate(new Date());
    
    const activeRental = allFutureEvents.find(e => e[3] === '貸出');

    if (activeRental) {
        itemValues[HEADER.indexOf('ステータス')] = '貸出中';
        itemValues[HEADER.indexOf('貸与者')] = activeRental[4];
        itemValues[HEADER.indexOf('現場名')] = activeRental[5];
        // ▼▼▼ 修正: Dateオブジェクトを明示的に日付文字列（yyyy/MM/dd）に変換して保存する ▼▼▼
        itemValues[HEADER.indexOf('貸出日')] = Utilities.formatDate(normalizeDate(activeRental[6]), Session.getScriptTimeZone(), 'yyyy/MM/dd');
        itemValues[HEADER.indexOf('返却予定日')] = Utilities.formatDate(normalizeDate(activeRental[7]), Session.getScriptTimeZone(), 'yyyy/MM/dd');
        // ▲▲▲ 修正ここまで ▲▲▲
    } else {
        // 予約開始日(貸与日)が今日以降の予約を探す
        const upcomingReservation = allFutureEvents.find(e => 
            e[3] === '予約' && normalizeDate(e[6]) >= today
        );
        
        itemValues[HEADER.indexOf('ステータス')] = upcomingReservation ? '予約あり' : '在庫';
        itemValues[HEADER.indexOf('貸与者')] = '';
        itemValues[HEADER.indexOf('現場名')] = '';
        itemValues[HEADER.indexOf('貸出日')] = '';
        itemValues[HEADER.indexOf('返却予定日')] = '';
    }
    itemRange.setValues([itemValues]);
}

function getFutureEventsForItem(itemId) {
    const lastRow = rentalSheet.getLastRow();
    if (lastRow < 2) return [];
    const values = rentalSheet.getRange(2, 1, lastRow - 1, HISTORY_HEADER.length).getValues();
    const today = normalizeDate(new Date());

    return values
        .filter(row => {
            const isTargetItem = row[1] == itemId;
            const isFutureEvent = ['貸出', '予約'].includes(row[3]);
            const eventEndDate = normalizeDate(row[7]);
            return isTargetItem && isFutureEvent && eventEndDate >= today;
        })
        .sort((a,b) => normalizeDate(a[6]) - normalizeDate(b[6]));
}

function checkAvailability(itemId, newStart, newEnd, isEditingLend = false, historyIdToIgnore = null) {
    const normalizedStart = normalizeDate(newStart);
    const normalizedEnd = normalizeDate(newEnd);

    const futureEvents = getFutureEventsForItem(itemId);

    for (const event of futureEvents) {
        if (String(event[0]) === String(historyIdToIgnore)) continue;

        const eventStart = normalizeDate(event[6]);
        const eventEnd = normalizeDate(event[7]);
        
        if (normalizedStart <= eventEnd && normalizedEnd >= eventStart) {
            const reason = `${event[3]}あり (${Utilities.formatDate(eventStart, 'JST', 'yyyy/MM/dd')} ~ ${Utilities.formatDate(eventEnd, 'JST', 'yyyy/MM/dd')})`;
            return { isAvailable: false, conflictReason: reason };
        }
    }
    return { isAvailable: true };
}

function findRowById(sheet, id) {
    if (!id || sheet.getLastRow() < 2) return -1;
    const ids = sheet.getRange(2, 1, sheet.getLastRow() - 1, 1).getValues().flat();
    const rowIndex = ids.findIndex(cellId => String(cellId) == String(id));
    return (rowIndex !== -1) ? rowIndex + 2 : -1;
}

function formatRowAsObject(rowArray, headerArray) {
    let item = {};
    const DATE_KEYS = ['貸出日', '返却予定日', '校正日・入替日', '貸与日', '実返却日']; 
    headerArray.forEach((key, index) => {
        const value = rowArray[index];
        
        if (DATE_KEYS.includes(key)) {
            if (value instanceof Date) {
                // Dateオブジェクトならyyyy/MM/dd形式に変換
                item[key] = Utilities.formatDate(value, Session.getScriptTimeZone(), 'yyyy/MM/dd');
                
            } else if (typeof value === 'string' && value.trim() !== '') {
                // スプレッドシートが文字列として保存している場合（例: "2024/01/01"）はそのまま渡す
                item[key] = value;
            
            } else {
                // null, undefined, 空文字列などの場合は空欄
                item[key] = '';
            }
        } else {
            item[key] = value;
        }
    });
    return item;
}

function getNextId(sheet) {
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return 1;
    const ids = sheet.getRange(2, 1, lastRow - 1, 1).getValues().flat();
    const maxId = Math.max(0, ...ids.filter(id => !isNaN(id)).map(id => Number(id)));
    return isFinite(maxId) ? maxId + 1 : 1;
}

function normalizeDate(date) {
    if (!date) return null;
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    return d;
}

// ----------------------------------------------------------------
// メール送信用ヘルパー関数
// ----------------------------------------------------------------

/**
 * メールマスタシートから指定された種類のメールアドレスを取得する
 * @param {string} mailType - メール種類 (例: '編集')
 * @return {string[]} メールアドレスの配列
 */
function getMailMasterAddresses(mailType) {
    // mailSheet が存在しないか、定義されていない場合は警告を出し空配列を返す
    if (typeof mailSheet === 'undefined' || !mailSheet) {
        console.warn("「メールマスタ」シートが見つからないか、スクリプト内で定義されていません。");
        return [];
    }
    try {
        const lastRow = mailSheet.getLastRow();
        if (lastRow < 2) return []; // ヘッダーのみの場合は空

        // A列: 送り先, B列: メール種類, C列: アドレス と想定
        const values = mailSheet.getRange(2, 1, lastRow - 1, 3).getValues();
        
        const addresses = values
            .filter(row => row[1] === mailType && row[2]) // B列(インデックス1)がmailTypeと一致し、C列(インデックス2)にアドレスがある
            .map(row => row[2].trim()) // C列のアドレスを取得
            .filter(address => address.length > 0 && address.includes('@')); // 空白や無効なアドレスを除外

        return [...new Set(addresses)]; // 重複を除外して返す
    } catch (e) {
        console.error(`getMailMasterAddresses Error: ${e.message} ${e.stack}`);
        return [];
    }
}

/**
 * 操作完了通知メールを送信する
 * @param {string} formEmail - フォームから入力されたメールアドレス (カンマ区切り)
 * @param {string} subject - メールの件名
 * @param {string} body - メールの本文
 */
function sendNotificationEmail(formEmail, subject, body) {
    let recipients = [];

    // 1. フォームからのアドレスを追加
    if (formEmail) {
        const emailsFromForm = formEmail.split(',')
            .map(email => email.trim())
            .filter(email => email.length > 0 && email.includes('@'));
        recipients = recipients.concat(emailsFromForm);
    }

    // 2. メールマスタ（'編集'）からのアドレスを追加
    const masterAddresses = getMailMasterAddresses('編集');
    recipients = recipients.concat(masterAddresses);

    // 3. 宛先の重複を除外し、空でなければ送信
    const uniqueRecipients = [...new Set(recipients)].filter(email => email); // 再度重複と空を除外

    if (uniqueRecipients.length > 0) {
        try {
            const recipientString = uniqueRecipients.join(',');
            MailApp.sendEmail({
                to: recipientString,
                subject: subject,
                body: body,
                // noReply: true // メールの差出人を「返信不可」にする場合は、このコメントアウトを解除
            });
            console.log(`メール送信成功: ${recipientString}`);
        } catch (e) {
            console.error(`メール送信エラー: ${e.message} ${e.stack}`);
            // メール送信エラーは操作の成功/失敗に影響させない（ログに残すのみ）
        }
    } else {
        console.log("通知先アドレスが指定されていないため、メールは送信されませんでした。");
    }
}

/**
 * 物品IDから物品名を取得する（メール本文用）
 * @param {string} itemId
 * @return {string} 物品名
 */
function getItemNameById(itemId) {
    try {
        const itemRow = findRowById(itemSheet, itemId);
        if (itemRow === -1) return `不明な物品(ID: ${itemId})`;
        // HEADERの'物品名'のインデックス(1) + 1 = 2列目
        return itemSheet.getRange(itemRow, HEADER.indexOf('物品名') + 1).getValue();
    } catch (e) {
        console.error(`getItemNameById Error: ${e.message}`);
        return `不明な物品(ID: ${itemId})`;
    }
}
